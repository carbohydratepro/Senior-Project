from wordcloud import WordCloud
import matplotlib.pyplot as plt
from janome.tokenizer import Tokenizer
from janome.analyzer import Analyzer
from janome.charfilter import *
from janome.tokenfilter import *

def create_wordcloud(text):
    # ストップワードの設定
    stopwords = ["の", "に", "は", "を", "た", "が", "で", "て", "と", "し", "れ", "さ", "ある", "いる", "も", "する", "から", "な", "こと", "として", "い", "や", "れる", "など", "なっ", "ない", "この", "ため", "その", "あっ", "よう", "また", "もの", "という", "あり", "まで", "られ", "なる", "へ", "か", "だ", "これ", "によって", "により", "おり", "より", "による", "ず", "なり", "られる", "において", "ば", "なかっ", "なく", "しかし", "について", "せ", "だっ", "その後", "できる", "それ", "う", "ので", "なお", "のみ", "でき", "き", "つ", "における", "および", "いう", "さらに", "でも", "ら", "たり", "その他", "に関する", "たち", "ます", "ん", "なら", "に対して", "特に", "せる", "及び", "これら", "とき", "では", "にて", "ほか", "ながら", "うち", "そして", "とともに", "ただし", "かつて", "それぞれ", "または", "に対する", "ほとんど", "と共に", "といった", "です", "とも", "ところ", "ここ"]

    # Janomeトークナイザのインスタンス化
    t = Tokenizer()

    # フィルターの設定
    char_filters = [UnicodeNormalizeCharFilter(), RegexReplaceCharFilter(u'蛇の目', u'janome')]
    token_filters = [CompoundNounFilter(), POSStopFilter(['名詞,非自立', '助詞', '助動詞', '動詞,非自立']), LowerCaseFilter(), ExtractAttributeFilter('base_form')]
    a = Analyzer(char_filters=char_filters, tokenizer=t, token_filters=token_filters)

    # 単語を分割
    words = list(a.analyze(text))

    # 単語をスペースでつなげる
    word_chain = " ".join(words)

    # ワードクラウドの生成
    wordcloud = WordCloud(font_path="C:\\Windows\\Fonts\\meiryo.ttc", background_color="white", width=800,height=600).generate(word_chain)
    wordcloud.to_file("wordcloud.png")

    # ワードクラウドの表示
    plt.imshow(wordcloud, interpolation='bilinear')
    plt.axis("off")
    plt.show()

# 使用例
text = """
論文作成上の注意\n\n下記の項目は，過去提出時に不備があり受理されなかった項目\n\n(cid:15)概要は800文字以内（750〜800字とする）であること\n\n700文字以下や801文字以上は受理されないことがある\n\n(cid:15)受領書，概要2部(1部はファイルに綴じる)，本文，ファイルの背\n\n表紙 、表紙のタイトルが一致していること\n\n(cid:15)年度と提出日の年号は同じではない\n\n\u3000例\u3000表紙が2010年度の論文では提出日は2011年となているは ず\n\n(cid:15)参考文献，図・表番号は，必ず本文中に参照番号を記述すること\n\n(cid:15)図・表番号は章毎に下記のように章番号．章内の通し番号をつけ\n\n る\n\u3000例\u3000図⇒図1.1\u3000表⇒表2.3\n\n(cid:15)式については「次式のように」，「・・についての式を下記に示す．」\nのような場合，本文に番号をつ けないでよい（情報処理学会など、\n\n参照がなくても式番号がついている場合もある）\n\n(cid:15)式番号で本文中に参照したい場合は，式の後に（章番号．章 内の\n\n通し番号）をつけ、本文中で参照する\n\u3000例\u3000対照となる式(3.2)\n\n(cid:15)文章の適当な箇所でインデント（字下げ）を行い，インデントの\n前で"Enterキー"を2回入れる（￥￥としないこと\u3000￥￥では字下\nげされない）\n\n\x0c必要事項を記入し、卒業論文と一緒に提出すること\n\n卒業論文受領 証学生保管\n\n学籍番号\n\nC\n\n0\n\n1\n\n0\n\n7\n\n4\n\n1\n\n2\n\n氏名\n\n遊佐和哉\n\n受領印を受けた後、本票を受け取り\n\n大切に保管してください。\n\n受領印\n\n卒業論文受領証事務局保管\n\n学籍番号\n\nC\n\n0\n\n1\n\n0\n\n7\n\n4\n\n1\n\n2\n\n受領印\n\n氏名\n\n指導教員\n\n論文題目\n\n遊佐和哉\n\n坪川宏\n\nP2Pネットワークにおける\n処理待機時間低減のための\n動的分散処理方式の検討\n\n\x0c東京工科大学\n\n卒業論文\n\n論文題目\n\nP2Pネットワーク における処理待機時間低減のための\n動的分散処理方式の検討\n\n指導教員\n\n坪川宏\n\n提出日\n\n2011年1月24日\n\n提出者\n\n学部\n\nコンピュータサイエンス学部\n\n学籍番号\n\nC0107412\n\n氏名\n\n遊佐和哉\n\n\x0c2010年度\n\n卒業論文\n\n概\n\n要\n\n論文題目\n\nP2Pネットワークにおける処理待機時間低減のための\n動的分散処理方式の検討\n\nコンピュータ\nサイエンス学部\n\n学籍番号\n\nC0107412\n\n氏\n\n名\n\n遊佐和哉\n\n指\n導\n教\n員\n\n坪川宏\n\nネッ トワークを介して複数のコンピュータを結ぶことで，大規模な計算を高速\nにおこなうグリッド・コンピューティングが注目されている．P2Pによる分散コン\nピューティングもその例である．分散コンピューティングとは膨大なタスクを小さ\nく分割した上で多くのコンピュータで分散して処理をする手法である．\n\nしかし ながら，P2Pによる分散コンピューティングにおいて，各ノードに処理を\n行わせる時，単純に負荷を均一に分散させると，各ノードの処理時間にばらつきが\n発生し，全体の処理時間が最も処理速度の遅いノードの処理時間に依存してしまう．\nこの依存によって，処理速度の速いノードが担当していた処理を完了すると，全 体\nの処理が完了するまで待機状態となってしまう問題点がある．また，P2Pサービス\nにおいてはノードの参加・離脱が発生することを前提として，サービスを継続でき\nることが求められる．\n\nそこで，担当していた処理を完了したノードは，別ノードの完了していない処理\nの一部を受け取り，処理を継続することで待 機状態となることを防ぐ分散処理方式\nを提案する．また，ノードの参加・離脱に伴い，タスクの割当・引き継ぎを行うこ\nとで，サービスの効率的な継続と全体 の処理時間の短縮を目的としている．\n\n本研究では，オーバーレイ構築ツールキット「OverlayWeaver」をフレームワー\nクに用いてシステムを実装している．フレームワークを用いて構築されるネットワー\nクには，担当サーバ決め手法である「ConsistentHashing」に基づいたリング上の構\n造化オーバーレイネットワークを利用している．\n\nこれにより，各ノードの待機時間を30[s]以内に短縮することができ，従来の手\n法や関連研究の手法よりも全体の処理時間を短縮することができた．また，ノード\nの参加・離脱が発生しても提案手法が有効に動作していることが確認できた．\n\n\x0c目次\n\n第1章はじめに\n\n1.1背景::::::::::::::::::::::::::::::::::::\n1.2目的::::::::::::::::::::::::::::::::::::\n1.3論文の構成::::::::::::::::::::::::::::::::\n\n第2章既存技術との比較\n\n2.1関連サービス:::::::::::::::::::::::::::::::\n2.2関連研究::::::::::::::::::::::::::::::::::\n2.3手法の提案::::::::::::::::::::::::::::::::\n\n第3章提 案システムについて\n\n3.1システム概要:::::::::::::::::::::::::::::::\n3.1.1ネットワーク概要:::::::::::::::::::::::::\n3.1.2システム全体の流れ:::::::::::::::::::::::\n3.2使用技術::::::::::::::::::::::::::::::::::\n3.2.1P2Pネットワークについて::::::::::::::::::::\n3.2.2OverlayWeaver::::::::::::::::::::::::::\n3.2.3XML-RPC:::::::::::::::::::::::::::::\nJetty::::::::::::::::::::::::::::::::\n3.2.4\n3.2.5ConsistentHashing::::::::::::::::::::::::\n3.3タスク管理::::::::::::::::::::::::::::::::\n3.3.1タスク分割::::::::::::::::::::::::::::\n3.3.2タスク移譲::::::::::::::::::::::::::::\n3.4ノード管理::::::::::::::::::::::::::::::::\n3.4.1ノード参加時:::::::::::::::::::::::::::\n3.4.2ノード離脱時:::::::::::::::::::::::::::\n\n第4章提案システムの実装\n\n4.1XML-RPC通信部:::::::::::::::::::::::::::::\n4.2Webサーバ::::::::::::::::::::::::::::::::\n4.3タスク管理::::::::::::::::::::::::::::::::\n4.3.1タスク分割::::::::::::::::::::::::::::\n\ni\n\n1\n1\n2\n2\n\n3\n3\n3\n4\n\n5\n5\n5\n5\n6\n6\n7\n8\n9\n9\n10\n10\n11\n12\n12\n13\n\n14\n14\n15\n16\n16\n\n\x0c4.3.2タスク移譲::::::::::::::::::::::::::::\n4.4ノード管理::::::::::::::::::::::::::::::::\n4.4.1参加処理::::::::::::::::::::::::::::::\n4.4.2離脱処理::::::::::::::::::::::::::::::\n4.4.3生存確認::::::::::::::::::::::::::::::\n\n第5章動作検証\n\n5.1動作環境::::::::::::::::::::::::::::::::::\n5.2検証方法::::::::::::::::::::::::::::::::::\n5.2.1待機時間の検証::::::::::::::::::::::::::\n5.2.2ノード参加・離脱処理の検 証::::::::::::::::::\n5.3検証結果::::::::::::::::::::::::::::::::::\n5.3.1待機時間の検証結果:::::::::::::::::::::::\n5.3.2ノード参加・離脱処理の検 証結果::::::::::::::::\n\n第6章おわりに\n\n6.1考察::::::::::::::::::::::::::::::::::::\n6.2課題::::::::::::::::::::::::::::::::::::\n\n謝辞\n\n参考文献\n\n17\n17\n17\n18\n18\n\n19\n19\n19\n19\n20\n20\n20\n21\n\n23\n23\n24\n\n25\n\n26\n\nii\n\n\x0c第1章はじめに\n\n1.1背景\n\n近年の計算機の性能 向上には目を見張るものがある．パーソナルコンピュータにも，\n\n高速なプロセッサ及び大容量のメモリを搭載したものが普及しており，さらには広帯\n域のネ ットワークによってそれらが相互に接続されている．しかし，このような豊富\nな計算資源があるにもかかわらず，プロセッサの能力を限界まで使用している場合 は\n少なく，むしろ遊休状態にある計算機が多数であると考えられる．このように，計算\n資源を決して有効に利用できていないのが現状であり，計算タスクを適 切に分散し計\n算資源を有効利用するためのシステムが重要になっている．\n\nネットワークを介して複数のコンピュータを結ぶことで，大規模な計算を高速にお\nこなうグリッド・コンピューティングが注目されている．資源情報の管理やタスクの\nスケジューリングは専用のサーバを用いて行うことが一般的であるが，これらのサー\nバに負荷が集中して障害が生じ，システムがダウンする可能性がある．その対策とし\nて高性能なサーバの導入が考えられるが，コストが高いという問 題がある．また，ク\nライアント・サーバの接続形態では，ネットワーク資源や計算機資源の分散化による\n特質を十分に活かしているとは言い難いという問題も ある．\n\nネットワークや計算機資源の分散化を実現する技術としてPeertoPeer(以降，P2P\nとする)と呼ばれる通信技術がある．P2P技術による分散化によって， ネットワーク\n遮断やコンピュータの障害等に耐性がある信頼性の高い分散コンピューティングの実\n現が可能となった．また，P2Pネットワークを構成する各ノードのユーザが，大規模\nな計算を安価な設備で行うことが可能となった．\n\nしかし，P2Pによる分散コンピューティングにおいて，各ノードに処理を行わせ\nる際，単純に負荷を均一に分散させると，各ノードの処理時間にばらつきが発生し，\n全体の処理時間が最も処理速度の遅いノードの処理時間に依存してしまう．この 依存\nによって，処理速度の速いノードが担当していた処理を完了すると，全体の処理が完\n了するまで待機状態となってしまう問題点がある．また，P2Pサービスにおいては\nノードの参加・離脱が発生することを前提として，サービスを継続できることが求め\nられる．\n\n1\n\n\x0c1.2目的\n\n本研究では，待機状態とな ってしまうノードが発生することを防ぐ分散処理方式を\n提案する．また，ノードの参加・離脱に伴い，タスクの割り当て・引き継ぎを行うこ\nとで，サービスの 効率的な継続と全体の処理時間の短縮を目的としている．\n\n提案する分散処理方式では，全てのタスク処理を完了したノードが，処理を完了し\nていないノード から処理の一部を受け取り，処理を継続することでサービスの効率的\nな継続を実現する．また，P2Pネットワークでのノードの参加・離脱時におけるノー\nドとタスクの管理を行うことで，データの損失をすることなく常に未処理タスクの実\n行を可能とする．\n\n1.3論文の構成\n\n本論文の構成は次の通りである．1章では ，本研究の背景と目的を述べた．続く2\n章では，従来の分散処理手法の特徴と問題点について述べ，関連研究との比較を含め\nた新たな分散処理手法の提案を行う．3章では，本研究で提案するシステムの概要と\nして，ネットワーク構造，システム全体の流れ，使用技術，タスク管理，ノード管理\nについて述べる．4章では ，本研究で提案したシステムの実装結果と処理の流れにつ\nいて述べる．5章では，本研究で実装したシステムの動作環境，評価について述べる．\n6章では，考察 と今後の課題について述べる．\n\n2\n\n\x0c第2章既存技術との比較\n\n2.1関連サービス\n\n分散コンピューティングとは膨大なタスク(仕事)を小さく分割した上で多くのコ\nンピュータで分散して処理をする方法である．一般に参加者を募っている分散コン\nピューティングプロジェクトが多くあり，既に目的とした問題解 決の成果を出したプ\nロジェクトもある．主なプロジェクトとして，「distributed.net」や「SETI@home」な\nどがある．\n\ndistributed.netでは，暗号解読によるプライバシー保護の訴え，全探索による数学\n的難問の証明などを行っており，SETI@homeでは，地球外から来る信号から非自然\n信号を抽出し，地球外生命体の探索を行っている．\n\nこれらはタスクの分散化という意味では分散コンピューティングに属しているが，\n\nクライアント・サーバの接続形態をとっているため ，ネットワーク資源や計算資源の\n分散化による特質を十分に活かしているとは言い難い．そこで，ネットワークや計算\n機資源の分散化を実現する技術であるP2Pを用いた分散コンピューティングの方式\nが提案されている．\n\n2.2関連研究\n\n研究の分野において，P2Pに基づく分散コンピューティングの一実験[1]やP2Pに\n\nおける分散ハッシュテーブルを用いた静的負荷分散方式[2]といった研究がある．\n\n前者の研究では，クライアント・サーバ形式の分散コンピューティングへ とP2P技\n術を導入し，データを部分共有化することで信頼性の高い分散コンピューティングを\n実現している．しかし，ハイブリットP2Pの接続形態をとっている ため，サーバと\nの通信が不能となった場合，データの復元は可能であっても処理を継続することがで\nきなくなる．\n\n後者の研究では，従来の分散処理方式の 問題点を指摘し，新たな方式を提案してい\nる．従来の方式では，各ノードに処理を行わせる際，単純に負荷を均一に分散させる\nと，各ノードの処理時間にばら つきが発生し，全体の処理時間が最も処理速度の遅い\nノードの処理時間に依存してしまう．そのため，各ノードの能力に応じて分散させる\nことで，負荷処理時 間の均一化により，全体としてより効率的な処理の実行を実現し\nている．しかし，処理中にノードの処理能力が変化した場合，従来の方式と同様に処\n理時間の ばらつきが発生し，負荷処理時間が均一化されなくなってしまう．\n\n3\n\n\x0c2.3手法の提案\n\n今までに述べたことから，P2Pネットワークを用いた分散コンピューティングでは\n特定のサーバを用いずに，ノードの処理能力が動的に変化した場合においても，負荷\n処理時間が均一化となることが理想であると考えられる ．\n\n本研究では，特定のサーバを必要としないピュアP2Pを用いた動的分散処理方式\nを提案する．各ノードで処理を実行させ，全てのタスク処理を完了させたノードは，\n全ての処理を完了していないノードからタスクの一部を受け取り，処理を継続するこ\nとで各ノードが待機状態となることを防ぎ，サービスの効率的な 継続を実現する．ま\nた，ノードの処理能力が動的に変化した場合においても，上記の方式が何度も実行さ\nれることで対応が可能であると考えられる．\n\n4\n\n\x0c第3章提案システムについて\n\n3.1システム概要\n\n3.1.1ネットワーク概要\n\n本システムでは，オーバーレイ構築ツールキットである「OverlayWeaver」を 使用\nし，リング状の構造化オーバーレイネットワークを構築している．このツールキット\nが提供している高レベルサービスのDHTを利用し，分散処理システムを実装してい\nる．OverlayWeaverが構築するオーバーレイネットワークの種類は，Chordアルゴリ\nズムを使った構造化オーバーレイとなっており，ルーティングド ライバにはiterative\nルーティング，通信プロトコルにはUDPを使用している．また，本システムはJava\n言語を用いて実装されている．\n\n3.1.2システム全体の流れ\n\nまず，P2Pネットワークを用いた分散処理を行うには，オーバーレイネットワーク\nを構成する必要がある．そのためには，オーバーレイネットワークを構成する各ノー\nドのユーザが本システムを事前に導入しておくことが必要となる．\n\n本システムを起動，オーバーレイネットワークを構成後，分散処理を依頼し たい\nユーザ(以降，依頼者とする)は，膨大なタスクを細分化し，各ノードへと割り当て\nる．各ノードは割り当てられたタスクを処理していき，一つのタスク処 理を完了する\nごとに結果を返す．全体の処理完了後，集計した結果が依頼者に呈示される．\n\n上記が基本的な流れとなるが，分散処理を実行中にノードの参加 ・離脱が発生した\n場合，隣接ノードからのタスクの割り当て・引き継ぎが行われる．また，割り当てら\nれたタスクの処理が全て完了したノードは，処理が完了 していないノードから処理の\n一部を請け負うことで，新たに処理を実行することとなる．\n\nこれらシステム全体の概要を図3.1に示す．\n\n5\n\n\x0c図3.1:シ ステム概要図\n\n3.2使用技術\n\n3.2.1P2Pネットワークについて\n\nPeertoPeer(P2P)とは，多数の端末間で通信を行う際のアーキテクチャのひとつ．\n\nP2Pにおける通信端末は，ピア(peer)またはノード(node)と呼ばれる．P2Pネット\nワークのノードはサーバとクライアントの両方の機能を持ち，互いに対等な関係で通\n信を行う．P2Pネットワークでは，インデックス情報の持ち方により，ハイブリット\nP2P，ピュアP2P，スーパーノード型P2Pの三つに分類される．\n\nハイブリットP2Pでは，インデックス情報を中央のインデックスサーバで一括管\n理する．そのため，ピア同士の直接接続を行う相手ノードの特定を行うためには，イ\nンデック スサーバに問い合わせる必要があるが，直接通信の内容はインデックスサー\nバを経由しない．インデックスサーバにノードからの検索要求の情報を蓄積すること\nができるほか，ノードの集中管理が容易であることが特徴である．しかし，インデッ\nクスサーバに障害が起こるとピア間での直接通信ができず，システム全体が停止する\nという欠点がある．\n\n6\n\n\x0cピュアP2Pでは，インデックス情報を各ノードが少しずつ分散して持ち合うため，\n特定のサーバを用いることなくピ ア同士の直接通信を行うことができる．ハイブリッ\nトP2Pのようにインデックスサーバを必要としないため，対障害性が高く多くのピ\nアが参加でき，大量のコンテンツが保有できるためスケーラビリティが高いことが特\n徴として挙げられる．また匿名性が高いためピアの制御や集中管理がしにくいことが\n最大の特徴であ り，問題点でもある．メッセージ転送の方式により，非構造化タイプ\nと構造化タイプの二つに分類できる．\n\nスーパーノード型P2Pでは，ピュアP2Pの変形型で ，一般ノードとは異なる高度\nな処理や，インデックス情報を管理するスーパーノードがネットワーク上に存在する\nことが特徴として挙げられる．スーパーノー ドには，一般のエンドユーザの端末から\nできるだけ安定な端末が処理能力に応じて選ばれ，スーパーノード群でネットワーク\nを構築し高機能なサービスの提供 を支援している．\n\n本研究では，各マシンの障害やネットワークの変化におけるデータ損失等の耐障害\n性に強いこと，ネットワークを構成する各ノードのユー ザが，大規模な計算を安価\nな設備でより効率的に，高速に処理が行えるようにすることを目的としているため，\nピュアP2Pモデルを採用する．\n\n3.2.2OverlayWeaver\n\nオーバーレイネットワークの構築を支援するツールキット[3]．オーバーレイネット\nワークのアプリケーション開発に加えて，オーバーレイのアルゴリズム設計もサポー\nトしている．OverlayWeaverにはランタイムと分散環境エミュレータ，エミュレー\nションシナリオ生成器，OverlayVisualizer，メッセージカ ウンタのツールがある．本\n研究ではランタイムのみを利用しているので，ここではOverlayWeaverのランタイ\nムについて述べる．ランタイムを構成するコンポーネント群を図3.2に示す．\n\nまず，ルーティング層は「ルーティングドライバ」「ルーティングアルゴリズム」\n「メッセージサービス」の三つで構成されている．このため既存のいくつかのアルゴ\nリズムを簡単に実装することが可能となった．OverlayWeaverで提供されているルー\nティングアルゴリズムとしてChord，Kademlia，Koorde，Pastry，Tapestryの五つが\nある．本システムが構築するネットワークは，担当サーバ決め手法である「Consistent\nHashing」に基づいたChordを使用している．\n\n次に，ルーティング層の上には，高レベルサービスが実装されている．Overlay\nWeaverの高レベルサービスとして，分散ハッシュ表であるDHT とマルチキャスト\nを提供している．本システムではノード検索を行うため，他のノードをすべて把握す\nる必要があり，構造化オーバーレイネットワークを構築 するため，DHTを利用して\nいる．\n\n7\n\n\x0c図3.2:ランタイムを構成するコンポーネント群\n\n最後に，アプリケーション層ではサンプルアプリケーションと して，DHTシェル\nとMcastシェルとIPv4マルチキャストルータが提供されている．その中のDHTシェ\nルとMcastシェルはキャラクタ端末やネットワーク越しにコマ ンドを受け取ること\nで高レベルサービスを制御する機能を持っている．このため，エミュレータと併せて\n利用することで，オーバーレイアルゴリズムの検証な どを行うことができる．本シス\nテムでは高レベルサービスのDHTを制御するために，DHTシェルに拡張を行う形\nでP2Pネットワークを用いた分散処理システムを実装している．\n\n3.2.3XML-RPC\n\nRPCプロトコルの一つ[4]．RPCとはプログラムから他のコンピュータの手続きを\n実行する技術．ローカルコンピュータにあるプログラムを実行するようにリモートコ\nンピュータのプログラムを実行することが可能になる．エンコード(符号化)にXML\nを採用し，通信プロトコルにHTTPを採用している．非常に単純なプロトコルであ\nり，その仕様は2枚の紙にまとめられるほどで，多くのRPCシステムと比較すると\n際立った特徴である．通信プロトコル にHTTPを使用しているため，ファイアウォー\nルなどでフィルタリングされにくい．\n\n8\n\n\x0c本フレームワークが使用しているDHTシェルではXML-RPCプロトコルの手続き\nを受け付ける機能を提供しているが，XML-RPCプロトコルの手続きを送る機能が提\n供されていないので，本システムではXML-RPCを利用するために「Apache」の提\n供している「ApacheXML-RPC」[5]というライブラリを使用している．これによっ\nて，オーバーレイネットワーク上のノードにあるユーザが開発したプログラムを呼び\n出し，P2Pサービスのタスクを処理させている．\n\n3.2.4Jetty\n\nJavaでWebサーバを構築できるようにするためのサーブレットコンテナ[6]．サ\nイズが小さいので，組み込み型JavaアプリケーションにWebサービスを提供する\nのに適している．プラグインにより拡張性や柔軟性にも優れており，Apacheなどの\nHTTPサーバと連携することも可能である．\n\n本システムでは，ブラウザからフレームワークへアクセスし操作できるようにする\n\nために使用している．\n\n3.2.5ConsistentHashing\n\n担当サーバ決め手法の一つ．分散環境下において，複数台のキャッシュサーバがあ\nり，オブジェクトのキャッシュをどのサーバに配置するかを決める際，通常用いられ\nるハッシュ関数は式(3.1)となる．Hはオブジェクトのハッシュ値，Nはサーバの台\n数である．\n\n担当サーバ番号=HmodN\n\n(3.1)\n\nしかし，このハッシュ関数を用いる方法では，サーバの台数が変わるとほとんどの\n
"""
create_wordcloud(text)

